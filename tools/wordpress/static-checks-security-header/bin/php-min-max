#!/usr/bin/env php
<?php

declare(strict_types=1);

/**
 * PHP Version Compatibility Scanner CLI
 *
 * Scans PHP code to determine minimum and maximum PHP version compatibility.
 *
 * Usage:
 *   php bin/php-min-max <url|path> [options]
 *
 * Options:
 *   --output=FILE           Save JSON output to specified file
 *   --extensions=LIST       Comma-separated list of file extensions to scan (default: php)
 *   --insecure, -k          Skip SSL certificate verification
 *   --quiet, -q             Suppress progress messages (output only JSON)
 *   --help, -h              Show this help message
 *
 * Examples:
 *   php bin/php-min-max https://downloads.wordpress.org/plugin/akismet.zip
 *   php bin/php-min-max ./my-plugin.zip --output=results.json
 */

// Find autoloader
$autoloadPaths = [
    __DIR__ . '/../vendor/autoload.php',
    __DIR__ . '/../../vendor/autoload.php',
    __DIR__ . '/../../../autoload.php',
];

$autoloadFound = false;
foreach ($autoloadPaths as $autoloadPath) {
    if (file_exists($autoloadPath)) {
        require_once $autoloadPath;
        $autoloadFound = true;
        break;
    }
}

if (!$autoloadFound) {
    fwrite(STDERR, "Error: Could not find Composer autoloader.\n");
    fwrite(STDERR, "Please run 'composer install' first.\n");
    exit(1);
}

use FairForge\Tools\PhpMinMax\CompatibilityScanner;

/**
 * Parse command line arguments.
 *
 * @param array<int, string> $argv
 * @return array{target: string|null, options: array<string, mixed>}
 */
function parseArguments(array $argv): array
{
    $target = null;
    $options = [
        'output' => null,
        'extensions' => ['php'],
        'quiet' => false,
        'help' => false,
        'insecure' => false,
    ];

    // Skip script name
    array_shift($argv);

    foreach ($argv as $arg) {
        if ($arg === '--help' || $arg === '-h') {
            $options['help'] = true;
        } elseif ($arg === '--quiet' || $arg === '-q') {
            $options['quiet'] = true;
        } elseif ($arg === '--insecure' || $arg === '-k') {
            $options['insecure'] = true;
        } elseif (str_starts_with($arg, '--output=')) {
            $options['output'] = substr($arg, 9);
        } elseif (str_starts_with($arg, '--extensions=')) {
            $options['extensions'] = explode(',', substr($arg, 13));
        } elseif (!str_starts_with($arg, '-') && $target === null) {
            $target = $arg;
        }
    }

    return ['target' => $target, 'options' => $options];
}

/**
 * Print help message.
 */
function printHelp(): void
{
    $versions = implode(', ', CompatibilityScanner::PHP_VERSIONS);
    echo <<<HELP
PHP Version Compatibility Scanner

Determines minimum and maximum PHP version compatibility for PHP packages
using PHPCompatibility sniffs. A version "passes" if there are no fatal
errors - warnings are noted but don't cause a version to fail.

USAGE:
    php bin/php-min-max <url|path> [options]

ARGUMENTS:
    <url|path>              URL to a ZIP file or path to a local ZIP/directory

OPTIONS:
    --output=FILE           Save JSON output to specified file
    --extensions=LIST       Comma-separated list of file extensions (default: php)
    --insecure, -k          Skip SSL certificate verification
    --quiet, -q             Suppress progress messages (output only JSON)
    --help, -h              Show this help message

EXAMPLES:
    # Check a WordPress plugin from wordpress.org
    php bin/php-min-max https://downloads.wordpress.org/plugin/akismet.zip

    # Check a local ZIP file and save results
    php bin/php-min-max ./my-plugin.zip --output=results.json

    # Check a local directory
    php bin/php-min-max ./src/

    # Quiet mode - only JSON output
    php bin/php-min-max plugin.zip --quiet

PHP VERSIONS CHECKED:
    {$versions}

OUTPUT:
    JSON output includes:
    - min_version: Lowest PHP version that passes (no fatal errors)
    - max_version: Highest PHP version that passes (no fatal errors)
    - version_range: Human-readable range (e.g., ">=7.4 <=8.4")
    - composer_constraint: Composer-compatible constraint
    - passed/failed/warning version details
    - All compatibility issues with affected versions

EXIT CODES:
    0 - Scan completed, package is compatible with at least one version
    1 - Scan completed, package has no compatible versions
    2 - Scan could not be completed due to an error

HELP;
}

/**
 * Print a message to stderr if not in quiet mode.
 */
function info(string $message, bool $quiet): void
{
    if (!$quiet) {
        fwrite(STDERR, $message . "\n");
    }
}

// Main execution
$parsed = parseArguments($argv);
$options = $parsed['options'];
$target = $parsed['target'];

if ($options['help']) {
    printHelp();
    exit(0);
}

if ($target === null) {
    fwrite(STDERR, "Error: No input URL or file path provided.\n\n");
    fwrite(STDERR, "Usage: php bin/php-min-max <url|path> [options]\n");
    fwrite(STDERR, "Run 'php bin/php-min-max --help' for more information.\n");
    exit(2);
}

// Configure scanner
$scanner = new CompatibilityScanner();
$scanner->setExtensions($options['extensions']);
$scanner->setSslVerify(!$options['insecure']);

if ($options['insecure']) {
    info("WARNING: SSL verification disabled", $options['quiet']);
}

info("PHP Version Compatibility Scanner", $options['quiet']);
info("==================================", $options['quiet']);
info("Checking versions: " . implode(', ', CompatibilityScanner::PHP_VERSIONS), $options['quiet']);
info("", $options['quiet']);

try {
    // Determine if target is URL, local ZIP, or directory
    if (filter_var($target, FILTER_VALIDATE_URL)) {
        info("Downloading: {$target}", $options['quiet']);
        $result = $scanner->scanFromUrl($target);
    } elseif (is_dir($target)) {
        info("Scanning directory: {$target}", $options['quiet']);
        $result = $scanner->scanDirectory($target);
    } elseif (file_exists($target)) {
        info("Scanning ZIP file: {$target}", $options['quiet']);
        $result = $scanner->scanFromZipFile($target);
    } else {
        fwrite(STDERR, "Error: '{$target}' is not a valid URL, directory, or existing file.\n");
        exit(2);
    }

    info("Scan completed!", $options['quiet']);
    info("", $options['quiet']);

    // Output results
    $json = $result->toJson();

    if ($options['output']) {
        if ($result->saveToFile($options['output'])) {
            info("Results saved to: {$options['output']}", $options['quiet']);
        } else {
            fwrite(STDERR, "Error: Failed to save results to {$options['output']}\n");
            exit(2);
        }
    }

    // Always output JSON to stdout (unless quiet and output file specified)
    if (!$options['quiet'] || !$options['output']) {
        echo $json . "\n";
    }

    // Print summary if not quiet
    if (!$options['quiet']) {
        $summary = $result->getSummary();
        fwrite(STDERR, "\n");
        fwrite(STDERR, "Summary:\n");
        fwrite(STDERR, "  Minimum PHP version: " . ($summary['min_version'] ?? 'N/A') . "\n");
        fwrite(STDERR, "  Maximum PHP version: " . ($summary['max_version'] ?? 'N/A') . "\n");
        fwrite(STDERR, "  Version range: " . ($summary['version_range'] ?? 'N/A') . "\n");
        fwrite(STDERR, "  Composer constraint: " . ($summary['composer_constraint'] ?? 'N/A') . "\n");
        fwrite(STDERR, "  Versions passed: {$summary['passed_count']}\n");
        fwrite(STDERR, "  Versions failed: {$summary['failed_count']}\n");
        fwrite(STDERR, "  Total issues: {$summary['issue_count']}\n");
    }

    // Exit with appropriate code
    exit($result->hasPassingVersions() ? 0 : 1);

} catch (Throwable $e) {
    fwrite(STDERR, "Error: " . $e->getMessage() . "\n");
    if (!$options['quiet']) {
        fwrite(STDERR, "Stack trace:\n" . $e->getTraceAsString() . "\n");
    }
    exit(2);
}
